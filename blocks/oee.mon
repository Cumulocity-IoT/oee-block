package apamax.analyticsbuilder.oee;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.L10N;
using apama.analyticsbuilder.Value;
using apama.analyticsbuilder.TimerParams;
using com.apama.json.JSONPlugin;
using com.apama.exceptions.Exception;
using com.apama.util.AnyExtractor;

event Oee_$Parameters {

    /**
     * Interval
     *
     * The interval for which the OEE should be calculated.
     **/
    float interval;
    constant float $DEFAULT_interval := 600.0;

    /**
     * Ideal Cycle Amount
     *
     * The theoretical maximum that can be produced in a single interval.
     **/
    float ica;

}

event Oee_$State {
    integer calculation_path;
    action<Activation, float, float, float, float, float> oee_calculation;
    TimeInStateExpressionParser machine_status;
    dictionary<string,StatefulExpressionParser> sep;
    dictionary<string,sequence<OutputValue>> results;
}


/**
* OEE
*
* TODO: explanation and restrictions on inputs
*  
* @$blockCategory Aggregates
*/
event Oee {

	BlockBase $base;
	Oee_$Parameters $parameters;

    action $validate() {
        if(path() = 0) {
            throw Exception("Unexpected combination of inputs", "IllegalArgumentException");
        }
    }

    action path() returns integer {
        boolean apa := $base.getInputCount("pieces") = 1;
        boolean aqa := $base.getInputCount("pieces_ok") = 1;
        boolean qla := $base.getInputCount("pieces_nok") = 1;
        boolean qok := $base.getInputCount("qok") = 1;
        boolean status := $base.getInputCount("status") = 1;
        if(status and apa and aqa and not qla and not qok) {
            return 1;
        }
        if(status and apa and qok and not qla and not aqa) {
            return 2;
        }
        if(status and aqa and qla and not apa and not qok) {
            return 3;
        }
        if(status and apa and qla and not aqa and not qok) {
            return 4;
        }
        return 0;
    }

	action setupCalculation(Activation $activation, Oee_$State $blockState) {
        if($blockState.calculation_path=1) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.ACTUAL_QUALITY_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.results[OEE.ACTUAL_PRODUCTION_TIME] := new sequence<OutputValue>;
            $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT] := new sequence<OutputValue>;
            $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT] := new sequence<OutputValue>;
        } else if($blockState.calculation_path=2) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.results[OEE.ACTUAL_PRODUCTION_TIME] := new sequence<OutputValue>;                                   
            $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT] := new sequence<OutputValue>;
            $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT] := new sequence<OutputValue>;
            // quality status handler
        } else if($blockState.calculation_path=3) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_QUALITY_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.QUALITY_LOSS_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.results[OEE.ACTUAL_PRODUCTION_TIME] := new sequence<OutputValue>;
            $blockState.results[OEE.QUALITY_LOSS_AMOUNT] := new sequence<OutputValue>;
            $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT] := new sequence<OutputValue>;
        } else if($blockState.calculation_path=4) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.QUALITY_LOSS_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));            
            $blockState.results[OEE.ACTUAL_PRODUCTION_TIME] := new sequence<OutputValue>;
            $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT] := new sequence<OutputValue>;
            $blockState.results[OEE.QUALITY_LOSS_AMOUNT] := new sequence<OutputValue>;

        }
	}

	action applyToMachineStatus(TimeInStateExpressionParser tisep, InputValue iv) returns sequence<OutputValue> {
        sequence<OutputValue> result := new sequence<OutputValue>;
        boolean stateChanged := tisep.evaluateWith(iv);
        if(tisep.currentInterval.isAfter(iv.time)) {	
            sequence<Interval> intervals := tisep.currentInterval.intervalsTo(iv.time);
            Interval timespan;
            for timespan in intervals {
                if (timespan.end <= iv.time) {
                    float value := float.parse((tisep.timeInStateForInterval(true, timespan)).formatFixed(OEE.DECIMAL_PRECISION));
                    result.append(OutputValue(timespan.end, value));
                }
            }
            tisep.currentInterval.adjustTo(iv.time);
            tisep.cleanup(tisep.currentInterval.start);
        }
        if (stateChanged) {
            // TODO needed?
            route MachineStatus.build(OEE.machineStatus(tisep.state), "", tisep.intervalName()).forTime(iv.time);
        }
        return result;
	}


	action applyToTransformationRule(string inputName, StatefulExpressionParser sep, InputValue iv) returns sequence<OutputValue> {
        sequence<OutputValue> result := new sequence<OutputValue>;

        if(sep.currentInterval.isIn(iv.time)) {
            any intermediate := sep.evaluateWith(iv);
            if(not intermediate.empty()) {
                // TODO needed?
                route InternalAmount(inputName, sep.intervalName(), iv.time, (<float>intermediate));
            }
        } else if(sep.currentInterval.isAfter(iv.time)) {
            float previous := Util.anyToFloat(sep.value);
            sequence<InputValue> splitSequence := sep.ep.split(iv, sep.currentInterval);
            if(splitSequence.size()=0) {	
                float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                sequence<Interval> intervals := sep.currentInterval.intervalsTo(iv.time);
                Interval first := intervals[0];
                Interval last := intervals[intervals.size()-1];
                Interval int;
                for int in intervals {
                    if(int=first) {
                        // TODO needed?                        
                        log "Route " + InternalAmount(inputName, sep.intervalName(), int.end, val-previous); 
                        route InternalAmount(inputName, sep.intervalName(), int.end, val-previous);								
                    }
                    if(int!=last) {
                        result.append(OutputValue(int.end, val));
                        val := (<float>sep.startValue);
                    }
                }
                sep.currentInterval.adjustTo(iv.time);
            } else {
                InputValue first := splitSequence[0];
                InputValue last := splitSequence[splitSequence.size()-1];
                InputValue sa;
                for sa in splitSequence {
                    float ia := Util.anyToFloat(sep.evaluateWith(sa));
                    if(sa=first) {
                        float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                        result.append(OutputValue(sa.time, val));
                        // TODO needed?                        
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    }
                    if(sa!=last and sa !=first) {
                        float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                        result.append(OutputValue(sa.time, val));
                        // TODO needed?                        
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    } 
                    if(sa=last and sa !=first) {
                        float val := float.parse((<float>sep.value).formatFixed(OEE.DECIMAL_PRECISION));
                        // TODO needed?
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    }
                    sep.currentInterval.adjustTo(sa.time);					
                }
            }
        }
        return result;	
	}

	action performOEECalculation_APT_APA_AQA(Activation $activation, float interval, float timestamp, 
                                float actualProductionTime, float actualProductionAmount, float actualQualityAmount) {

		float idealCycleAmount := $parameters.ica;
		float cycleLength := interval / idealCycleAmount;
		float idealCycleTime := cycleLength; 
		float potentialProductionTime := interval;

		// Level 2
		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float qualityLossAmount := actualProductionAmount - actualQualityAmount;
		
		// Level 3
		float availabilityLossAmount := idealAmount - idealProductionAmount;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		float performanceLossTime := actualProductionTime - idealMachineRuntime;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;
		
		// Level 4
		float availabilityLossTime := (availabilityLossAmount / idealCycleAmount) * cycleLength;
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}
		
		// Level 5
		float oee := availability * performance * quality;

        $setOutput_oee($activation, oee);
        $setOutput_availability($activation, availability);
        $setOutput_performance($activation, performance);
        $setOutput_quality($activation, quality);
        $setOutput_timestamp($activation, timestamp);

        Value details := new Value;
        details.value := true;
        details.timestamp := timestamp;
        details.properties := {
            OEE.OEE: oee,
            OEE.PERFORMANCE: performance,
            OEE.AVAILABILTY: availability,
            OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount,
            OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount,
            OEE.IDEAL_AMOUNT: idealAmount,
            OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime,
            OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime,
            OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount,
            OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount,
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime,
            OEE.QUALITY_LOSS_TIME: qualityLossTime,
            OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        $setOutput_details($activation, details);
	}

	action performOEECalculation_APT_AQA_QLA(Activation $activation, float interval, float timestamp, 
                                float actualProductionTime, float actualQualityAmount, float qualityLossAmount) {
	
    	float idealCycleAmount := $parameters.ica;
		float cycleLength := interval / idealCycleAmount;
		float idealCycleTime := cycleLength; 
		float potentialProductionTime := interval;
         
		// Level 2
		float availabilityLossTime := potentialProductionTime - actualProductionTime; 
		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;
		float actualProductionAmount := actualQualityAmount + qualityLossAmount;
		
		// Level 3
		float availabilityLossAmount := (availabilityLossTime * idealCycleAmount) / cycleLength; 
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		
		// Level 4
		float performanceLossTime := ((performanceLossAmount / idealCycleAmount) * cycleLength);
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}
		
		// Level 5
		float oee := availability * performance * quality;
		
        $setOutput_oee($activation, oee);
        $setOutput_availability($activation, availability);
        $setOutput_performance($activation, performance);
        $setOutput_quality($activation, quality);
        $setOutput_timestamp($activation, timestamp);

        Value details := new Value;
        details.value := true;
        details.timestamp := timestamp;
        details.properties := {
            OEE.OEE: oee,
            OEE.PERFORMANCE: performance,
            OEE.AVAILABILTY: availability,
            OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount,
            OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount,
            OEE.IDEAL_AMOUNT: idealAmount,
            OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime,
            OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime,
            OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount,
            OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount,
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime,
            OEE.QUALITY_LOSS_TIME: qualityLossTime,
            OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        $setOutput_details($activation, details);
    }

	action performOEECalculation_APT_APA_QLA(Activation $activation, float interval, float timestamp, 
                                float actualProductionTime, float actualProductionAmount, float qualityLossAmount) {

    	float idealCycleAmount := $parameters.ica;
		float cycleLength := interval / idealCycleAmount;
		float idealCycleTime := cycleLength; 
		float potentialProductionTime := interval;

		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float actualQualityAmount := actualProductionAmount - qualityLossAmount;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;

		// Level 3
		float availabilityLossAmount := idealAmount - idealProductionAmount;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;

		// Level 4
		float availabilityLossTime := (availabilityLossAmount / idealCycleAmount) * cycleLength;
		float performanceLossTime := ((performanceLossAmount / idealCycleAmount) * cycleLength);
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}
		
		// Level 5
		float oee := availability * performance * quality;

        $setOutput_oee($activation, oee);
        $setOutput_availability($activation, availability);
        $setOutput_performance($activation, performance);
        $setOutput_quality($activation, quality);
        $setOutput_timestamp($activation, timestamp);

        Value details := new Value;
        details.value := true;
        details.timestamp := timestamp;
        details.properties := {
            OEE.OEE: oee,
            OEE.PERFORMANCE: performance,
            OEE.AVAILABILTY: availability,
            OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount,
            OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount,
            OEE.IDEAL_AMOUNT: idealAmount,
            OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime,
            OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime,
            OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount,
            OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount,
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime,
            OEE.QUALITY_LOSS_TIME: qualityLossTime,
            OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        $setOutput_details($activation, details);
    }

    action setupBlockState(Oee_$State $blockState) {
        $blockState.calculation_path := path();
        if($blockState.calculation_path=1 or $blockState.calculation_path=2) {
            $blockState.oee_calculation := performOEECalculation_APT_APA_AQA;
        } else if($blockState.calculation_path=3) {
            $blockState.oee_calculation := performOEECalculation_APT_AQA_QLA;
        } else if($blockState.calculation_path=4) {
            $blockState.oee_calculation := performOEECalculation_APT_APA_QLA;
        }
    }

    /**
     *
     * @param $activation The current activation.
	 * @param $input_pieces The produced piece count.
     * @$inputName pieces Pieces.
	 * @param $input_pieces_ok The ok piece count.
     * @$inputName pieces_ok Pcs Ok
	 * @param $input_pieces_nok The not ok piece count.
     * @$inputName pieces_nok Pcs NOk.
	 * @param $input_qok Quality indicator.
     * @$inputName qok Quality Ok.
	 * @param $input_status Machine availability status indicator.
     * @$inputName pieces Machine Status.
	 */
    action $process(Activation $activation, Value $input_pieces, 
                    Value $input_pieces_ok, Value $input_pieces_nok, Value $input_qok,
                    Value $input_status, Oee_$State $blockState) {
        
        if($blockState.calculation_path=0) {
            setupBlockState($blockState);
            setupCalculation($activation, $blockState);
        }

        if(now($activation,$input_status)) {
            InputValue iv := InputValue($input_pieces.timestamp, <boolean>$input_status.value, 1.0);
            sequence<OutputValue> result := applyToMachineStatus($blockState.machine_status, iv);
            $blockState.results[OEE.ACTUAL_PRODUCTION_TIME].appendSequence(result);
        }

        if(now($activation,$input_pieces)) {
            InputValue iv := InputValue($input_pieces.timestamp, <float>$input_pieces.value, 1.0);
            sequence<OutputValue> result := applyToTransformationRule(OEE.ACTUAL_PRODUCTION_AMOUNT, $blockState.sep[OEE.ACTUAL_PRODUCTION_AMOUNT], iv);
            $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT].appendSequence(result);
        }

        if(now($activation,$input_pieces_ok)) {
            InputValue iv := InputValue($input_pieces_ok.timestamp, <float>$input_pieces_ok.value, 1.0);
            sequence<OutputValue> result := applyToTransformationRule(OEE.ACTUAL_QUALITY_AMOUNT, $blockState.sep[OEE.ACTUAL_QUALITY_AMOUNT], iv);
            $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT].appendSequence(result);
        }

        sequence<OutputValue> aptr := $blockState.results[OEE.ACTUAL_PRODUCTION_TIME];
        sequence<OutputValue> apar := $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT];        
        sequence<OutputValue> aqar := $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT];
        log "APTs " + aptr;
        log "APAs " + apar;
        log "AQAs " + aqar;
        sequence<float> toClear := new sequence<float>; 
        OutputValue apa;
        for apa in apar {
            optional<OutputValue> apt := findin(aptr,apa.time);
            optional<OutputValue> aqa := findin(aqar,apa.time);
            ifpresent apt,aqa {
                performOEECalculation_APT_APA_AQA($activation, $parameters.interval, apa.time, $parameters.interval, apa.value, aqa.value);
                toClear.append(apa.time);
            }
        }
        $blockState.results[OEE.ACTUAL_PRODUCTION_TIME] := clear(aptr, toClear);
        $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT] := clear(apar, toClear);
        $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT] := clear(aqar, toClear);
        // apply to inputs
        // take into account machine status for other inputs
        // other calculation methods
    }

    action clear(sequence<OutputValue> s, sequence<float> toClear) returns sequence<OutputValue> {
        sequence<OutputValue> s_new := new sequence<OutputValue>;
        OutputValue v;
        for v in s {
            if(toClear.indexOf(v.time)=-1) {
                s_new.append(v);
            }
        }
        return s_new;
    }

    action findin(sequence<OutputValue> s, float time) returns optional<OutputValue> {
        OutputValue v;
        for v in s {
            if(v.time=time) {
                return optional<OutputValue>(v);
            }
        }
        return new optional<OutputValue>;
    }

    action now(Activation $activation, Value v) returns boolean {
        return $activation.timestamp=v.timestamp; 
    }

    /**
     * OEE
     *
     * The calculated OEE for the interval.
     **/
    action<Activation,float> $setOutput_oee;
    /**
     * Availability
     *
     * The calculated availability for the interval.
     **/
    action<Activation,float> $setOutput_availability;
    /**
     * Performance
     *
     * The calculated performance for the interval.
     **/
    action<Activation,float> $setOutput_performance;
    /**
     * Quality
     *
     * The calculated quality for the interval.
     **/
    action<Activation,float> $setOutput_quality;
    /**
     * Timestamp
     *
     * The timestamp marking the end of the calculated interval.
     **/
    action<Activation,float> $setOutput_timestamp;
    /**
     * Details
     *
     * Details of the calculation including all components of the 
     * OEE calculation:
	 * <ul>
     * <li>OEE</li>
     * <li>Availability</li>
     * <li>Performance</li>
     * <li>Quality</li>
     * <li>Actual Production Amount</li>
     * <li>Actual Production Time</li>
     * <li>Actual Quality Amount</li>
     * <li>Ideal Amount</li>
     * <li>Ideal Cycle Time</li>
     * <li>Ideal Qualiy Time</li>
     * <li>Ideal Machine Runtime</li>
     * <li>Quality Loss Amount</li>
     * <li>Availability Loss Amount</li>
     * <li>Performance Loss Amount</li>
     * <li>Performance Loss Time</li>
     * <li>Quality Loss Time</li>
     * <li>Availability Loss Time</li>
     * <li></li>
     * <li></li>
	 * </ul>     
     **/
    action<Activation,Value> $setOutput_details;
    constant string $OUTPUT_TYPE_details := "pulse";
}
