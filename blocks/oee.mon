package apamax.analyticsbuilder.oee;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.L10N;
using apama.analyticsbuilder.Value;
using apama.analyticsbuilder.TimerParams;
using com.apama.json.JSONPlugin;
using com.apama.exceptions.Exception;
using com.apama.util.AnyExtractor;

event Oee_$Parameters {

    /**
     * Interval
     *
     * The interval for which the OEE should be calculated.
     **/
    float interval;
    constant float $DEFAULT_interval := 600.0;

    /**
     * Ideal Cycle Amount
     *
     * The theoretical maximum that can be produced in a single interval.
     **/
    float ica;

}

event Oee_$State {
    integer calculation_path;
    string output1;
    string output2;
    string output3;
    action<float, float, float, float> returns Value oee_calculation;
    TimeInStateExpressionParser machine_status;
    dictionary<string,StatefulExpressionParser> sep;
    dictionary<string,sequence<OutputValue>> results;
}


/**
* OEE
*
* TODO: explanation and restrictions on inputs
*  
* @$blockCategory Aggregates
*/
event Oee {

	BlockBase $base;
	Oee_$Parameters $parameters;

    action $validate() {
        if(path() = 0) {
            throw Exception("Unexpected combination of inputs", "IllegalArgumentException");
        }
    }

    action path() returns integer {
        boolean apa := $base.getInputCount("pieces") = 1;
        boolean aqa := $base.getInputCount("pieces_ok") = 1;
        boolean qla := $base.getInputCount("pieces_nok") = 1;
        boolean qok := $base.getInputCount("qok") = 1;
        boolean status := $base.getInputCount("status") = 1;
        if(status and apa and aqa and not qla and not qok) {
            return 1;
        }
        if(status and apa and qok and not qla and not aqa) {
            return 2;
        }
        if(status and aqa and qla and not apa and not qok) {
            return 3;
        }
        if(status and apa and qla and not aqa and not qok) {
            return 4;
        }
        return 0;
    }

	action setupCalculation(Activation $activation, Oee_$State $blockState) {
        $blockState.calculation_path := path();
        if($blockState.calculation_path=1 or $blockState.calculation_path=2) {
            $blockState.oee_calculation := performOEECalculation_APT_APA_AQA;
            $blockState.output1 := OEE.ACTUAL_PRODUCTION_TIME;
            $blockState.output2 := OEE.ACTUAL_PRODUCTION_AMOUNT;
            $blockState.output3 := OEE.ACTUAL_QUALITY_AMOUNT;
        } else if($blockState.calculation_path=3) {
            $blockState.oee_calculation := performOEECalculation_APT_AQA_QLA;
            $blockState.output1 := OEE.ACTUAL_PRODUCTION_TIME;
            $blockState.output2 := OEE.ACTUAL_QUALITY_AMOUNT;
            $blockState.output3 := OEE.QUALITY_LOSS_AMOUNT;
        } else if($blockState.calculation_path=4) {
            $blockState.output1 := OEE.ACTUAL_PRODUCTION_TIME;
            $blockState.output2 := OEE.ACTUAL_PRODUCTION_AMOUNT;
            $blockState.output3 := OEE.QUALITY_LOSS_AMOUNT;
            $blockState.oee_calculation := performOEECalculation_APT_APA_QLA;
        }
            $blockState.results[$blockState.output1] := new sequence<OutputValue>;
            $blockState.results[$blockState.output2] := new sequence<OutputValue>;
            $blockState.results[$blockState.output3] := new sequence<OutputValue>;

        if($blockState.calculation_path=1) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.ACTUAL_QUALITY_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
        } else if($blockState.calculation_path=2) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            // TODO quality status handler
        } else if($blockState.calculation_path=3) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_QUALITY_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.QUALITY_LOSS_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
        } else if($blockState.calculation_path=4) {
            $blockState.machine_status := TimeInStateExpressionParser.parseText("value", $activation.timestamp, $parameters.interval);
            $blockState.sep.add(OEE.ACTUAL_PRODUCTION_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));
            $blockState.sep.add(OEE.QUALITY_LOSS_AMOUNT, 
                                StatefulExpressionParser.parseText("value", Util.sum, Util.diff, 0.0, $activation.timestamp, $parameters.interval));            
        }
	}

	action applyToMachineStatus(TimeInStateExpressionParser tisep, InputValue iv) returns sequence<OutputValue> {
        sequence<OutputValue> result := new sequence<OutputValue>;
        boolean stateChanged := tisep.evaluateWith(iv);
        if(tisep.currentInterval.isAfter(iv.time)) {	
            sequence<Interval> intervals := tisep.currentInterval.intervalsTo(iv.time);
            Interval timespan;
            for timespan in intervals {
                if (timespan.end <= iv.time) {
                    float value := float.parse((tisep.timeInStateForInterval(true, timespan)).formatFixed(OEE.DECIMAL_PRECISION));
                    result.append(OutputValue(timespan.end, value));
                }
            }
            tisep.currentInterval.adjustTo(iv.time);
            tisep.cleanup(tisep.currentInterval.start);
        }
        if (stateChanged) {
            // TODO needed?
            route MachineStatus.build(OEE.machineStatus(tisep.state), "", tisep.intervalName()).forTime(iv.time);
        }
        return result;
	}


	action applyToTransformationRule(string inputName, StatefulExpressionParser sep, InputValue iv) returns sequence<OutputValue> {
        sequence<OutputValue> result := new sequence<OutputValue>;

        if(sep.currentInterval.isIn(iv.time)) {
            any intermediate := sep.evaluateWith(iv);
            if(not intermediate.empty()) {
                // TODO needed?
                route InternalAmount(inputName, sep.intervalName(), iv.time, (<float>intermediate));
            }
        } else if(sep.currentInterval.isAfter(iv.time)) {
            float previous := Util.anyToFloat(sep.value);
            sequence<InputValue> splitSequence := sep.ep.split(iv, sep.currentInterval);
            if(splitSequence.size()=0) {	
                float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                sequence<Interval> intervals := sep.currentInterval.intervalsTo(iv.time);
                Interval first := intervals[0];
                Interval last := intervals[intervals.size()-1];
                Interval int;
                for int in intervals {
                    if(int=first) {
                        // TODO needed?                        
                        log "Route " + InternalAmount(inputName, sep.intervalName(), int.end, val-previous); 
                        route InternalAmount(inputName, sep.intervalName(), int.end, val-previous);								
                    }
                    if(int!=last) {
                        result.append(OutputValue(int.end, val));
                        val := (<float>sep.startValue);
                    }
                }
                sep.currentInterval.adjustTo(iv.time);
            } else {
                InputValue first := splitSequence[0];
                InputValue last := splitSequence[splitSequence.size()-1];
                InputValue sa;
                for sa in splitSequence {
                    float ia := Util.anyToFloat(sep.evaluateWith(sa));
                    if(sa=first) {
                        float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                        result.append(OutputValue(sa.time, val));
                        // TODO needed?                        
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    }
                    if(sa!=last and sa !=first) {
                        float val := float.parse((<float>sep.retrieveAndReset()).formatFixed(OEE.DECIMAL_PRECISION));
                        result.append(OutputValue(sa.time, val));
                        // TODO needed?                        
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    } 
                    if(sa=last and sa !=first) {
                        float val := float.parse((<float>sep.value).formatFixed(OEE.DECIMAL_PRECISION));
                        // TODO needed?
                        route InternalAmount(inputName, sep.intervalName(), sa.time, ia);
                    }
                    sep.currentInterval.adjustTo(sa.time);					
                }
            }
        }
        return result;	
	}

	action performOEECalculation_APT_APA_AQA(float interval, float actualProductionTime, float actualProductionAmount, float actualQualityAmount) returns Value {
		float idealCycleAmount := $parameters.ica;
		float cycleLength := interval;
		float idealCycleTime := cycleLength / idealCycleAmount; 
		float potentialProductionTime := interval;
		// Level 2
		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float qualityLossAmount := actualProductionAmount - actualQualityAmount;
		// Level 3
		float availabilityLossAmount := idealAmount - idealProductionAmount;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		float performanceLossTime := actualProductionTime - idealMachineRuntime;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;	
		// Level 4
		float availabilityLossTime := (availabilityLossAmount / idealCycleAmount) * cycleLength;
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}
		// Level 5
		float oee := availability * performance * quality;

        Value details := new Value;
        details.properties := {OEE.OEE: oee, OEE.PERFORMANCE: performance, OEE.AVAILABILTY: availability, OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount, OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount, OEE.IDEAL_AMOUNT: idealAmount, OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime, OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime, OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount, OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount, 
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime, OEE.QUALITY_LOSS_TIME: qualityLossTime, OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        return details;
	}

	action performOEECalculation_APT_AQA_QLA(float interval, float actualProductionTime, float actualQualityAmount, float qualityLossAmount) returns Value {
		float idealCycleAmount := $parameters.ica;
		float cycleLength := interval;
		float idealCycleTime := cycleLength / idealCycleAmount; 
		float potentialProductionTime := interval;  
		// Level 2
		float availabilityLossTime := potentialProductionTime - actualProductionTime; 
		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;
		float actualProductionAmount := actualQualityAmount + qualityLossAmount;
		// Level 3
		float availabilityLossAmount := (availabilityLossTime * idealCycleAmount) / cycleLength; 
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		// Level 4
		float performanceLossTime := ((performanceLossAmount / idealCycleAmount) * cycleLength);
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}
		// Level 5
		float oee := availability * performance * quality;
		
        Value details := new Value;
        details.properties := {OEE.OEE: oee, OEE.PERFORMANCE: performance, OEE.AVAILABILTY: availability, OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount, OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount, OEE.IDEAL_AMOUNT: idealAmount, OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime, OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime, OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount, OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount, 
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime, OEE.QUALITY_LOSS_TIME: qualityLossTime, OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        return details;
    }

	action performOEECalculation_APT_APA_QLA(float interval, float actualProductionTime, float actualProductionAmount, float qualityLossAmount) returns Value {
		float idealCycleAmount := $parameters.ica;
		float cycleLength := interval;
		float idealCycleTime := cycleLength / idealCycleAmount; 
		float potentialProductionTime := interval;
        // Level 2
		float idealAmount := (potentialProductionTime / cycleLength) * idealCycleAmount;
		float idealProductionAmount := (actualProductionTime / cycleLength) * idealCycleAmount;
		float idealMachineRuntime := (actualProductionAmount / idealCycleAmount) * cycleLength;
		float actualQualityAmount := actualProductionAmount - qualityLossAmount;
		float qualityLossTime := (qualityLossAmount / idealCycleAmount) * cycleLength;
		// Level 3
		float availabilityLossAmount := idealAmount - idealProductionAmount;
		float performanceLossAmount := idealProductionAmount - actualProductionAmount;
		float idealQualityTime := (actualQualityAmount / idealCycleAmount) * cycleLength;
		// Level 4
		float availabilityLossTime := (availabilityLossAmount / idealCycleAmount) * cycleLength;
		float performanceLossTime := ((performanceLossAmount / idealCycleAmount) * cycleLength);
		float availability := 0.0;
		if(potentialProductionTime > 0.0) {
			availability := actualProductionTime / potentialProductionTime;
		}
		float performance := 0.0;
		if(actualProductionTime > 0.0) {
			performance := idealMachineRuntime / actualProductionTime;
		}
		float quality := 0.0;
		if(actualProductionAmount > 0.0) {
			quality := actualQualityAmount / actualProductionAmount;
		}	
		// Level 5
		float oee := availability * performance * quality;

        Value details := new Value;
        details.properties := {OEE.OEE: oee, OEE.PERFORMANCE: performance, OEE.AVAILABILTY: availability, OEE.QUALITY: quality,
            OEE.ACTUAL_PRODUCTION_AMOUNT: actualProductionAmount, OEE.ACTUAL_PRODUCTION_TIME: actualProductionTime,
            OEE.ACTUAL_QUALITY_AMOUNT: actualQualityAmount, OEE.IDEAL_AMOUNT: idealAmount, OEE.IDEAL_CYCLE_TIME: idealCycleTime,
            OEE.IDEAL_QUALITY_TIME: idealQualityTime, OEE.IDEAL_MACHINE_RUNTIME: idealMachineRuntime, OEE.QUALITY_LOSS_AMOUNT: qualityLossAmount,
            OEE.AVAILABILITY_LOSS_AMOUNT: availabilityLossAmount, OEE.PERFORMANCE_LOSS_AMOUNT: performanceLossAmount, 
            OEE.PERFORMANCE_LOSS_TIME: performanceLossTime, OEE.QUALITY_LOSS_TIME: qualityLossTime, OEE.AVAILABILITY_LOSS_TIME: availabilityLossTime
        };
        return details;
    }

    /**
     *
     * @param $activation The current activation.
	 * @param $input_pieces The produced piece count.
     * @$inputName pieces Pieces.
	 * @param $input_pieces_ok The ok piece count.
     * @$inputName pieces_ok Pcs Ok
	 * @param $input_pieces_nok The not ok piece count.
     * @$inputName pieces_nok Pcs NOk.
	 * @param $input_qok Quality indicator.
     * @$inputName qok Quality Ok.
	 * @param $input_status Machine availability status indicator.
     * @$inputName pieces Machine Status.
	 */
    action $process(Activation $activation, Value $input_pieces, 
                    Value $input_pieces_ok, Value $input_pieces_nok, Value $input_qok,
                    Value $input_status, Oee_$State $blockState) {
        
        if($blockState.calculation_path=0) {
            setupCalculation($activation, $blockState);
        }
        InputValue iv := InputValue($activation.timestamp, <boolean>$input_status.value);
        sequence<OutputValue> result := applyToMachineStatus($blockState.machine_status, iv);
        $blockState.results[OEE.ACTUAL_PRODUCTION_TIME].appendSequence(result);

        if(now($activation,$input_pieces)) {
            log "Pieces";
            InputValue iv := InputValue($input_pieces.timestamp, <float>$input_pieces.value);
            sequence<OutputValue> result := applyToTransformationRule(OEE.ACTUAL_PRODUCTION_AMOUNT, $blockState.sep[OEE.ACTUAL_PRODUCTION_AMOUNT], iv);
            $blockState.results[OEE.ACTUAL_PRODUCTION_AMOUNT].appendSequence(result);
        }

        if(now($activation,$input_pieces_ok)) {
            log "Pieces ok";
            InputValue iv := InputValue($input_pieces_ok.timestamp, <float>$input_pieces_ok.value);
            sequence<OutputValue> result := applyToTransformationRule(OEE.ACTUAL_QUALITY_AMOUNT, $blockState.sep[OEE.ACTUAL_QUALITY_AMOUNT], iv);
            $blockState.results[OEE.ACTUAL_QUALITY_AMOUNT].appendSequence(result);
        }

        if(now($activation,$input_pieces_nok)) {
            log "Pieces nok";
            InputValue iv := InputValue($input_pieces_nok.timestamp, <float>$input_pieces_nok.value);
            sequence<OutputValue> result := applyToTransformationRule(OEE.QUALITY_LOSS_AMOUNT, $blockState.sep[OEE.QUALITY_LOSS_AMOUNT], iv);
            $blockState.results[OEE.QUALITY_LOSS_AMOUNT].appendSequence(result);
        }

        log "Output1 : " + $blockState.results[$blockState.output1];
        log "Output2 : " + $blockState.results[$blockState.output2];
        log "Output3 : " + $blockState.results[$blockState.output3];


        log "All : " + $blockState.results;


        sequence<float> toClear := new sequence<float>; 
        OutputValue output1;
        for output1 in $blockState.results[$blockState.output1] {
            optional<OutputValue> output2 := findin($blockState.results[$blockState.output2],output1.time);
            optional<OutputValue> output3 := findin($blockState.results[$blockState.output3],output1.time);
            ifpresent output2,output3 {
                Value details := roundResults($blockState.oee_calculation($parameters.interval, output1.value, output2.value, output3.value));
                details.value := true;
                details.timestamp := output1.time;
                $setOutput_oee($activation, <float>details.properties[OEE.OEE]);
                $setOutput_availability($activation, <float>details.properties[OEE.AVAILABILTY]);
                $setOutput_performance($activation, <float>details.properties[OEE.PERFORMANCE]);
                $setOutput_quality($activation, <float>details.properties[OEE.QUALITY]);
                $setOutput_timestamp($activation, output1.time);
                $setOutput_details($activation, details);
                toClear.append(output1.time);
            }
        }
        $blockState.results[$blockState.output1] := clear($blockState.results[$blockState.output1], toClear);
        $blockState.results[$blockState.output2] := clear($blockState.results[$blockState.output2], toClear);
        $blockState.results[$blockState.output3] := clear($blockState.results[$blockState.output3], toClear);
        // TODO apply to all inputs
        // TODO take into account machine status for other inputs
        // TODO other calculation methods
    }

    action roundResults(Value result) returns Value {
        string key;
        for key in result.properties.keys() {
            float value := <float>result.properties[key];
            result.properties[key] := float.parse(value.formatFixed(OEE.DECIMAL_PRECISION));
        }
        return result;
    }

    action clear(sequence<OutputValue> s, sequence<float> toClear) returns sequence<OutputValue> {
        sequence<OutputValue> s_new := new sequence<OutputValue>;
        OutputValue v;
        for v in s {
            if(toClear.indexOf(v.time)=-1) {
                s_new.append(v);
            }
        }
        return s_new;
    }

    action findin(sequence<OutputValue> s, float time) returns optional<OutputValue> {
        OutputValue v;
        for v in s {
            if(v.time=time) {
                return optional<OutputValue>(v);
            }
        }
        return new optional<OutputValue>;
    }

    action now(Activation $activation, Value v) returns boolean {
        return $activation.timestamp=v.timestamp; 
    }

    /**
     * OEE
     *
     * The calculated OEE for the interval.
     **/
    action<Activation,float> $setOutput_oee;
    /**
     * Availability
     *
     * The calculated availability for the interval.
     **/
    action<Activation,float> $setOutput_availability;
    /**
     * Performance
     *
     * The calculated performance for the interval.
     **/
    action<Activation,float> $setOutput_performance;
    /**
     * Quality
     *
     * The calculated quality for the interval.
     **/
    action<Activation,float> $setOutput_quality;
    /**
     * Timestamp
     *
     * The timestamp marking the end of the calculated interval.
     **/
    action<Activation,float> $setOutput_timestamp;
    /**
     * Details
     *
     * Details of the calculation including all components of the 
     * OEE calculation:
	 * <ul>
     * <li>OEE</li>
     * <li>Availability</li>
     * <li>Performance</li>
     * <li>Quality</li>
     * <li>Actual Production Amount</li>
     * <li>Actual Production Time</li>
     * <li>Actual Quality Amount</li>
     * <li>Ideal Amount</li>
     * <li>Ideal Cycle Time</li>
     * <li>Ideal Qualiy Time</li>
     * <li>Ideal Machine Runtime</li>
     * <li>Quality Loss Amount</li>
     * <li>Availability Loss Amount</li>
     * <li>Performance Loss Amount</li>
     * <li>Performance Loss Time</li>
     * <li>Quality Loss Time</li>
     * <li>Availability Loss Time</li>
     * <li></li>
     * <li></li>
	 * </ul>     
     **/
    action<Activation,Value> $setOutput_details;
    constant string $OUTPUT_TYPE_details := "pulse";
}
